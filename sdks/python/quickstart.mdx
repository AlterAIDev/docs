---
title: 'Quickstart'
description: 'Start using the Alter SDK for Python in minutes'
---

Get started with the Alter SDK for Python to make authenticated API calls to any OAuth provider - without ever touching a token.

## Basic Setup

```python
import asyncio
from alter_sdk import AlterVault, Provider, HttpMethod

async def main():
    # Initialize the SDK
    vault = AlterVault(api_key="alter_key_...")

    # Make an API request - token is injected automatically
    response = await vault.request(
        Provider.GOOGLE,
        HttpMethod.GET,
        "https://www.googleapis.com/calendar/v3/calendars/primary/events",
        user={"user_id": "alice"},
        query_params={"maxResults": "10"},
    )
    events = response.json()

    for event in events.get("items", []):
        print(f"Event: {event['summary']}")

    await vault.close()

asyncio.run(main())
```

<Note>
  **Key Principle: Zero Token Exposure** - You never see or handle OAuth tokens. The SDK retrieves them from Alter Vault and injects them automatically. All token caching happens on the backend via Redis (under 10ms).
</Note>

## Architecture & Security

### Zero Token Exposure Design

Tokens are **never exposed** to your code - this is a fundamental security principle:

```python
# ✅ CORRECT - Token injected automatically behind the scenes
response = await vault.request(
    Provider.GOOGLE, HttpMethod.GET,
    "https://www.googleapis.com/calendar/v3/calendars/primary/events",
    user={"user_id": "alice"},
)

# ❌ IMPOSSIBLE - No method to access tokens directly
token = vault.get_token()  # This method doesn't exist by design!
```

### Dual HTTP Client Security

The SDK uses two separate HTTP clients to prevent credential leakage:

| Client | Purpose | Has API Key? | Talks To |
|--------|---------|:----------:|----------|
| **Alter client** | Token retrieval, audit logs | Yes | Alter backend only |
| **Provider client** | Your API calls | No | Google, GitHub, Slack, etc. |

This means your Alter API key **can never accidentally leak** to external provider APIs.

### No SDK-Side Caching

The SDK has **zero client-side token caching** to ensure:

- **Real-time policy enforcement** on every request
- **Complete audit trail** - backend logs all token access
- **Instant revocation** - no SDK cache delays
- **Fast performance** - backend Redis cache (under 10ms response)

### Automatic Audit Logging

All API calls are automatically logged as fire-and-forget background tasks:

```python
response = await vault.request(
    Provider.GOOGLE, HttpMethod.GET,
    "https://www.googleapis.com/calendar/v3/calendars/primary/events",
    user={"user_id": "alice"},
    reason="Fetching upcoming events for daily digest",
)
# ↑ Audit log sent in background with: provider, method, URL,
#   response status, latency, user context, and reason
```

### Policy Enforcement

Policies are enforced on **every token retrieval** using Cerbos. Only providers configured in your app can have policies.

| Policy Type | Description | Example |
|-------------|-------------|---------|
| **Scope Restrictions** | Limit which OAuth scopes can be retrieved | Only allow `calendar.readonly` |
| **Time-Based Access** | Restrict by time of day or day of week | Business hours only (9am-5pm), weekdays only |
| **IP Allowlist** | Restrict to specific IP addresses | Office network `203.0.113.0/24` |
| **Required Attributes** | Require connection metadata | Must have `user_id` and `org_id` |

Policies are configured per-provider in the Developer Portal under **App Details → Policies**.

## Configuration

```python
vault = AlterVault(
    api_key="alter_key_...",              # Required: API key from dashboard
    base_url="https://api.alter.com",     # Optional: Custom API endpoint
    enable_audit_logging=True,            # Optional: Enable audit logs (default: True)
    timeout=30.0,                         # Optional: HTTP timeout in seconds
)
```

## Core Concepts

### vault.request() - Single Entry Point

All provider API calls go through one method:

```python
response = await vault.request(
    provider,         # Provider enum or string (e.g., Provider.GOOGLE, "google")
    method,           # HttpMethod enum or string (e.g., HttpMethod.GET, "GET")
    url,              # Full URL of the provider API endpoint
    user={...},       # User attributes to match the OAuth connection
    json={...},       # Optional: JSON request body
    query_params={},  # Optional: URL query parameters
    path_params={},   # Optional: URL path template substitutions
    extra_headers={}, # Optional: Additional headers (Authorization is auto-injected)
    reason="...",     # Optional: Reason for audit trail
)
```

### Type-Safe Enums

Use enums for autocomplete and type safety:

```python
from alter_sdk import Provider, HttpMethod

# Provider enums
Provider.GOOGLE       # "google"
Provider.GITHUB       # "github"
Provider.SLACK        # "slack"
Provider.MICROSOFT    # "microsoft"
Provider.SALESFORCE   # "salesforce"

# HTTP method enums
HttpMethod.GET        # "GET"
HttpMethod.POST       # "POST"
HttpMethod.PUT        # "PUT"
HttpMethod.PATCH      # "PATCH"
HttpMethod.DELETE     # "DELETE"
HttpMethod.HEAD       # "HEAD"
HttpMethod.OPTIONS    # "OPTIONS"
```

Strings also work for forward compatibility:

```python
# These are equivalent
await vault.request(Provider.GOOGLE, HttpMethod.GET, url, user=user)
await vault.request("google", "GET", url, user=user)
```

### URL Path Templating

Use `{placeholder}` syntax for dynamic URL segments (values are automatically URL-encoded):

```python
response = await vault.request(
    Provider.SALESFORCE,
    HttpMethod.GET,
    "https://api.example.com/v1/accounts/{account_id}/contacts/{contact_id}",
    user={"user_id": "alice"},
    path_params={"account_id": "acc-123", "contact_id": "ct-456"},
)
# → GET https://api.example.com/v1/accounts/acc-123/contacts/ct-456
```

## Complete Examples

### Google Calendar Events

```python
from alter_sdk import AlterVault, Provider, HttpMethod

async def list_calendar_events(user_id: str):
    async with AlterVault(api_key="alter_key_...") as vault:
        response = await vault.request(
            Provider.GOOGLE,
            HttpMethod.GET,
            "https://www.googleapis.com/calendar/v3/calendars/primary/events",
            user={"user_id": user_id},
            query_params={
                "maxResults": "10",
                "singleEvents": "true",
                "orderBy": "startTime",
            },
        )
        events = response.json()

        for event in events.get("items", []):
            start = event["start"].get("dateTime", event["start"].get("date"))
            print(f"{start}: {event.get('summary', 'No title')}")

        return events
```

### GitHub Repositories

```python
async def list_repos(user_id: str):
    async with AlterVault(api_key="alter_key_...") as vault:
        response = await vault.request(
            Provider.GITHUB,
            HttpMethod.GET,
            "https://api.github.com/user/repos",
            user={"user_id": user_id},
            query_params={"sort": "updated", "per_page": "10"},
        )
        repos = response.json()

        for repo in repos:
            print(f"{repo['name']} - {repo.get('description', 'No description')}")
```

### Slack Message Posting

```python
async def post_slack_message(user_id: str, channel: str, text: str):
    async with AlterVault(api_key="alter_key_...") as vault:
        response = await vault.request(
            Provider.SLACK,
            HttpMethod.POST,
            "https://slack.com/api/chat.postMessage",
            user={"user_id": user_id},
            json={"channel": channel, "text": text},
            reason="Posting message to Slack",
        )
        data = response.json()

        if data.get("ok"):
            print(f"Message posted: {data['ts']}")
        else:
            print(f"Slack error: {data.get('error')}")
```

### POST with JSON Body

```python
async def create_item(user_id: str):
    async with AlterVault(api_key="alter_key_...") as vault:
        response = await vault.request(
            Provider.SALESFORCE,
            HttpMethod.POST,
            "https://api.example.com/v1/items",
            user={"user_id": user_id},
            json={"name": "New Item", "price": 99.99},
            reason="Creating new inventory item",
        )
        return response.json()
```

### Using Extra Headers

Some APIs require version headers or custom metadata:

```python
async def query_notion(user_id: str):
    async with AlterVault(api_key="alter_key_...") as vault:
        response = await vault.request(
            "notion",  # String works for any provider
            HttpMethod.POST,
            "https://api.notion.com/v1/databases/{db_id}/query",
            user={"user_id": user_id},
            path_params={"db_id": "abc123"},
            extra_headers={"Notion-Version": "2022-06-28"},
            json={"page_size": 10},
        )
        return response.json()
```

## Actor Tracking (AI Agents & MCP Servers)

If your application uses AI agents or MCP servers, actor tracking gives you full observability into **which agent** is making API calls and **why**.

### Why Actor Tracking?

When AI agents make OAuth-authenticated API calls on behalf of users, you need to know:
- **Which agent** accessed a user's data?
- **What was the context** (conversation thread, tool invocation)?
- **When and how often** did each agent make requests?

Actor tracking answers these questions automatically.

### Registering an Actor

Pass actor identity at SDK initialization:

```python
vault = AlterVault(
    api_key="alter_key_...",
    # Actor identity (required for tracking)
    actor_type="ai_agent",                # "ai_agent" or "mcp_server"
    actor_identifier="email-assistant-v2", # Unique ID for this agent
    # Actor metadata (optional)
    actor_name="Email Assistant",          # Human-readable name
    actor_version="2.0.0",                # Version string
    framework="langgraph",                # AI framework being used
)
```

For MCP servers:

```python
vault = AlterVault(
    api_key="alter_key_...",
    actor_type="mcp_server",
    actor_identifier="calendar-mcp",
    actor_name="Calendar MCP Server",
    actor_version="1.0.0",
    client_type="cursor",                 # MCP client type
)
```

### How Registration Works

1. **First request**: SDK sends `actor_type` + `actor_identifier` as HTTP headers
2. **Backend registers**: Actor is upserted in the database and assigned a UUID
3. **Backend responds**: UUID returned in `X-Alter-Actor-ID` response header
4. **SDK caches**: UUID is cached automatically for the session
5. **Subsequent requests**: Cached UUID is sent (skips database lookup)

This is fully automatic - you just configure the actor at initialization and the SDK handles the rest.

### Per-Request Tracking

Add execution-level context on each request:

```python
response = await vault.request(
    Provider.GOOGLE,
    HttpMethod.GET,
    "https://www.googleapis.com/calendar/v3/calendars/primary/events",
    user={"user_id": "alice"},
    # Per-request tracking (all optional)
    run_id="550e8400-e29b-41d4-a716-446655440000",  # Execution run ID
    thread_id="thread-abc-123",                       # Conversation thread
    tool_call_id="call_xyz_789",                      # Tool invocation ID
)
```

These fields are sent as headers to the backend and included in audit logs, giving you a complete trace from conversation → tool call → API request.

### Complete Agent Example

```python
import asyncio
from alter_sdk import AlterVault, Provider, HttpMethod

async def run_email_agent():
    vault = AlterVault(
        api_key="alter_key_...",
        actor_type="ai_agent",
        actor_identifier="email-assistant-v2",
        actor_name="Email Assistant",
        actor_version="2.0.0",
        framework="langgraph",
    )

    # Each tool call in the agent can be tracked
    response = await vault.request(
        Provider.GOOGLE,
        HttpMethod.GET,
        "https://gmail.googleapis.com/gmail/v1/users/me/messages",
        user={"user_id": "alice"},
        query_params={"maxResults": "5"},
        run_id="run-001",
        thread_id="thread-daily-digest",
        tool_call_id="call_read_emails",
        reason="Reading emails for daily digest",
    )

    messages = response.json()
    print(f"Found {len(messages.get('messages', []))} emails")

    await vault.close()

asyncio.run(run_email_agent())
```

### Actor Tracking Parameters Reference

**Initialization (set once per SDK instance):**

| Parameter | Type | Description | Example |
|-----------|------|-------------|---------|
| `actor_type` | `str` | `"ai_agent"` or `"mcp_server"` | `"ai_agent"` |
| `actor_identifier` | `str` | Unique identifier for the actor | `"email-assistant-v2"` |
| `actor_name` | `str` | Human-readable display name | `"Email Assistant"` |
| `actor_version` | `str` | Version of the actor | `"2.0.0"` |
| `framework` | `str` | AI framework name | `"langgraph"`, `"crewai"` |
| `client_type` | `str` | MCP client type | `"cursor"`, `"claude-desktop"` |

**Per-request (set on each `vault.request()` call):**

| Parameter | Type | Description | Example |
|-----------|------|-------------|---------|
| `run_id` | `str` | Execution run ID (UUID) | `"550e8400-..."` |
| `thread_id` | `str` | Conversation thread ID | `"thread-abc-123"` |
| `tool_call_id` | `str` | Tool invocation ID | `"call_xyz_789"` |

## Error Handling

<Warning>
  **Always handle errors explicitly.** Policy enforcement happens on EVERY token retrieval and can deny access based on configured rules.
</Warning>

### Exception Hierarchy

```
AlterSDKError (base)
├── TokenRetrievalError (backend errors)
│   ├── PolicyViolationError (403 - policy denied access)
│   ├── ConnectionNotFoundError (404 - no OAuth connection)
│   └── TokenExpiredError (400/502 - refresh failed)
├── ProviderAPIError (provider returned 4xx/5xx)
└── NetworkError (connection/timeout failures)
```

### Complete Error Handling Example

```python
from alter_sdk import AlterVault, Provider, HttpMethod
from alter_sdk.exceptions import (
    PolicyViolationError,
    ConnectionNotFoundError,
    TokenExpiredError,
    TokenRetrievalError,
    NetworkError,
    ProviderAPIError,
)

async def safe_api_call(user_id: str):
    async with AlterVault(api_key="alter_key_...") as vault:
        try:
            response = await vault.request(
                Provider.GOOGLE,
                HttpMethod.GET,
                "https://www.googleapis.com/calendar/v3/calendars/primary/events",
                user={"user_id": user_id},
            )
            return response.json()

        except PolicyViolationError as e:
            # Policy denied access (403) - check the reason
            print(f"Access denied by policy: {e.message}")
            print(f"Details: {e.details}")
            # Resolution: Check policy configuration in dashboard

        except ConnectionNotFoundError:
            # No OAuth connection for this user/provider (404)
            print("User hasn't connected Google yet")
            # Resolution: Redirect user to Alter Connect OAuth flow

        except TokenExpiredError as e:
            # Token refresh failed (400/502)
            print(f"Token expired for connection: {e.connection_id}")
            # Resolution: User needs to re-authenticate

        except TokenRetrievalError as e:
            # Other backend errors (401 invalid API key, 500/503 backend down)
            print(f"Backend error: {e.message}")

        except NetworkError as e:
            # Connection or timeout failure
            print(f"Network issue: {e.message}")
            # Resolution: Check network, retry with backoff

        except ProviderAPIError as e:
            # Provider API returned an error (4xx/5xx from Google, Slack, etc.)
            print(f"Provider error {e.status_code}: {e.response_body}")
            # Resolution: Check the provider's API docs
```

### Common Error Scenarios

| Exception | HTTP Status | Cause | Resolution |
|-----------|:-----------:|-------|------------|
| `PolicyViolationError` | 403 | Policy denied access | Check policy rules in dashboard |
| `ConnectionNotFoundError` | 404 | User has no OAuth connection | Redirect to Alter Connect UI |
| `TokenExpiredError` | 400/502 | Refresh token revoked/expired | User must re-authenticate |
| `TokenRetrievalError` | 401 | Invalid API key | Check your `api_key` |
| `TokenRetrievalError` | 400 | Provider not configured | Add provider in dashboard |
| `TokenRetrievalError` | 500/503 | Backend unavailable | Retry with backoff |
| `ProviderAPIError` | 4xx/5xx | Provider API error | Check provider docs |
| `NetworkError` | - | Connection refused/timeout | Check network, retry |

## Best Practices

<AccordionGroup>
  <Accordion title="Always Use Context Managers" icon="code">
    ```python
    # ✅ GOOD - Automatic cleanup
    async with AlterVault(api_key="alter_key_...") as vault:
        response = await vault.request(...)
    # Clients automatically closed

    # ❌ BAD - Manual cleanup required
    vault = AlterVault(api_key="alter_key_...")
    response = await vault.request(...)
    # Forgot to call vault.close()!
    ```
  </Accordion>

  <Accordion title="Handle Errors Explicitly" icon="shield-exclamation">
    ```python
    # ✅ GOOD - Explicit error handling
    try:
        response = await vault.request(...)
    except PolicyViolationError as e:
        logger.warning(f"Policy violation: {e.message}")
        return {"error": "Access denied by policy"}
    except ConnectionNotFoundError:
        return {"error": "Please connect your account first"}

    # ❌ BAD - Swallows all errors
    try:
        response = await vault.request(...)
    except Exception:
        pass
    ```
  </Accordion>

  <Accordion title="Pass Consistent User Attributes" icon="users">
    The `user` dict must match the attributes used when the connection was created.

    ```python
    # Single user
    user={"user_id": "alice"}

    # Multi-tenant SaaS
    user={"org_id": "acme", "user_id": "alice"}

    # Team shared connection
    user={"team_id": "engineering"}
    ```
  </Accordion>

  <Accordion title="Use Enums for Type Safety" icon="list">
    ```python
    from alter_sdk import Provider, HttpMethod

    # ✅ GOOD - Type-safe with autocomplete
    await vault.request(Provider.GOOGLE, HttpMethod.GET, url, user=user)

    # Also works - forward compatible for new providers
    await vault.request("notion", "GET", url, user=user)
    ```
  </Accordion>

  <Accordion title="Include Reasons for Audit" icon="clipboard-list">
    ```python
    # ✅ GOOD - Reason shows up in audit logs
    response = await vault.request(
        Provider.GOOGLE, HttpMethod.GET, url,
        user={"user_id": "alice"},
        reason="Fetching calendar events for weekly digest",
    )
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Quickstart Guide" icon="rocket" href="/quickstart">
    Full integration walkthrough with frontend + backend
  </Card>
  <Card title="Architecture" icon="building" href="/reference/architecture">
    Understand the security architecture
  </Card>
  <Card title="Audit Logs" icon="clipboard-list" href="/reference/audit-logs">
    Compliance and observability features
  </Card>
  <Card title="OpenClaw Plugin" icon="robot" href="/integrations/openclaw">
    AI agent OAuth integration
  </Card>
</CardGroup>
